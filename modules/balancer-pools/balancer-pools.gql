interface GqlPoolBase {
    #fields that never change after creation
    id: ID!
    name: String!
    symbol: String!
    address: Bytes!
    owner: Bytes
    factory: Bytes
    createdAt: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!

    dynamicData: GqlPoolDynamicData!
}

type GqlPoolDynamicData {
    poolId: ID!

    #fields that change rarely
    swapFee: BigDecimal!
    swapEnabled: Boolean!
    #fields that change often
    totalShares: BigDecimal!
    #data that has USD values
    composition: GqlPoolComposition! #token balances change often
    totalLiquidity: BigDecimal!
    volume24h: BigDecimal!
    fees24h: BigDecimal!
    totalSwapFee: BigDecimal!
    totalSwapVolume: BigDecimal!
    apr: GqlBalancePoolApr!
}

type GqlPoolInvestConfig {
    proportionalEnabled: Boolean!
    singleAssetEnabled: Boolean!
    options: [GqlPoolInvestOption!]!
}

type GqlPoolInvestOption {
    #we include the index because it is useful for constructing contract calls
    poolTokenIndex: Int!
    poolTokenAddress: String!

    # we use an array here for invest options where there are more than one option, but only one can be selected
    # - FTM/wFTM or ETH/wETH
    # - weighted boosted with nested phantom stable (bb-yv-USD) where you can only invest with DAI or USDC, not both at the same time
    tokenOptions: [GqlPoolToken!]!
}

type GqlPoolWithdrawConfig {
    proportionalEnabled: Boolean!
    singleAssetEnabled: Boolean!
    options: [GqlPoolWithdrawOption!]!
}

type GqlPoolWithdrawOption {
    poolTokenIndex: Int!
    poolTokenAddress: String!
    tokenOptions: [GqlPoolToken!]!
}

enum GqlPoolNestingType {
    NO_NESTING
    HAS_SOME_PHANTOM_BPT
    HAS_ONLY_PHANTOM_BPT
}

type GqlPoolWeighted implements GqlPoolBase {
    id: ID!
    name: String!
    symbol: String!
    address: Bytes!
    owner: Bytes!
    factory: Bytes
    createdAt: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!

    tokens: [GqlPoolTokenUnion!]!
    nestingType: GqlPoolNestingType!
}

type GqlPoolStable implements GqlPoolBase {
    id: ID!
    name: String!
    symbol: String!
    address: Bytes!
    owner: Bytes!
    factory: Bytes
    createdAt: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!

    tokens: [GqlPoolToken!]!
    amp: BigInt!
}

type GqlPoolPhantomStable implements GqlPoolBase {
    id: ID!
    name: String!
    symbol: String!
    address: Bytes!
    owner: Bytes!
    factory: Bytes
    createdAt: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    tokens: [GqlPoolTokenUnion!]!
    nestingType: GqlPoolNestingType!
}

type GqlPoolElement implements GqlPoolBase {
    id: ID!
    name: String!
    symbol: String!
    address: Bytes!
    owner: Bytes!
    factory: Bytes
    createdAt: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    tokens: [GqlPoolToken!]!

    #element specific fields
    unitSeconds: BigInt!
    principalToken: Bytes!
    baseToken: Bytes!
}

type GqlPoolLinear implements GqlPoolBase {
    id: ID!
    name: String!
    symbol: String!
    address: Bytes!
    owner: Bytes!
    factory: Bytes
    createdAt: Int!
    investConfig: GqlPoolInvestConfig!
    withdrawConfig: GqlPoolWithdrawConfig!
    dynamicData: GqlPoolDynamicData!
    tokens: [GqlPoolToken!]!

    #linear specific fields
    mainIndex: Int!
    wrappedIndex: Int!
    upperTarget: BigInt!
    lowerTarget: BigInt!
}

union GqlPoolTokenUnion = GqlPoolToken | GqlPoolTokenPhantomStable | GqlPoolTokenLinear

interface GqlPoolTokenBase {
    id: ID!
    address: String!
    balance: BigDecimal!
    decimals: Int!
    name: String!
    symbol: String!
    priceRate: BigDecimal!
    weight: BigDecimal
}

type GqlPoolToken implements GqlPoolTokenBase {
    id: ID!
    address: String!
    balance: BigDecimal!
    decimals: Int!
    name: String!
    symbol: String!
    priceRate: BigDecimal!
    weight: BigDecimal
}

type GqlPoolTokenLinear implements GqlPoolTokenBase {
    id: ID!
    address: String!
    balance: BigDecimal!
    decimals: Int!
    name: String!
    symbol: String!
    priceRate: BigDecimal!
    weight: BigDecimal

    pool: GqlPoolLinear!
    #the proportional balances of the underlying tokens, computed as the fraction balance / totalShares
    mainTokenBalance: BigDecimal!
    wrappedTokenBalance: BigDecimal!
    totalMainTokenBalance: BigDecimal! # mainTokenBalance + wrappedTokenBalance * priceRate
}

type GqlPoolTokenPhantomStable implements GqlPoolTokenBase {
    id: ID!
    address: String!
    balance: BigDecimal!
    decimals: Int!
    name: String!
    symbol: String!
    priceRate: BigDecimal!
    weight: BigDecimal

    pool: GqlPoolPhantomStable!
}

type GqlPoolLinearPoolData {
    id: ID!
    address: String!
    symbol: String!
    priceRate: String!
    mainToken: GqlPoolLinearPoolMainToken!
    wrappedToken: GqlPoolLinearPoolWrappedToken!
    unwrappedTokenAddress: String!
    totalSupply: String!
    balance: String!
    poolToken: String!
    mainTokenTotalBalance: String!
}

type GqlPoolStablePhantomPoolData {
    id: ID!
    address: String!
    symbol: String!
    tokens: [GqlPoolToken!]!
    totalSupply: String!
    balance: String!
}

type GqlPoolLinearPoolMainToken {
    address: String!
    index: Int!
    balance: String!
    totalSupply: String!
    name: String!
    symbol: String!
    decimals: Int!
}

type GqlPoolLinearPoolWrappedToken {
    address: String!
    index: Int!
    balance: String!
    totalSupply: String!
    priceRate: String!
    name: String!
    symbol: String!
    decimals: Int!
}

type GqlPoolComposition {
    tokens: [GqlPoolCompositionToken!]!
}

type GqlPoolCompositionToken {
    address: String!
    symbol: String!
    decimals: Int!
    weight: BigDecimal
    balance: BigDecimal!
    valueUSD: BigDecimal!

    nestedTokens: [GqlPoolCompositionToken!]
}

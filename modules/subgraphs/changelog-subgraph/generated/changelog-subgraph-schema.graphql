"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

scalar Bytes

interface EntityChangeEvent {
    action: String!
    block: BigInt!
    id: Bytes!
    timestamp: BigInt!
}

input EntityChangeEvent_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    action: String
    action_contains: String
    action_contains_nocase: String
    action_ends_with: String
    action_ends_with_nocase: String
    action_gt: String
    action_gte: String
    action_in: [String!]
    action_lt: String
    action_lte: String
    action_not: String
    action_not_contains: String
    action_not_contains_nocase: String
    action_not_ends_with: String
    action_not_ends_with_nocase: String
    action_not_in: [String!]
    action_not_starts_with: String
    action_not_starts_with_nocase: String
    action_starts_with: String
    action_starts_with_nocase: String
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

enum EntityChangeEvent_orderBy {
    action
    block
    id
    timestamp
}

type FarmChangeEvent implements EntityChangeEvent {
    action: String!
    block: BigInt!
    farmId: Int!
    id: Bytes!
    timestamp: BigInt!
}

input FarmChangeEvent_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    action: String
    action_contains: String
    action_contains_nocase: String
    action_ends_with: String
    action_ends_with_nocase: String
    action_gt: String
    action_gte: String
    action_in: [String!]
    action_lt: String
    action_lte: String
    action_not: String
    action_not_contains: String
    action_not_contains_nocase: String
    action_not_ends_with: String
    action_not_ends_with_nocase: String
    action_not_in: [String!]
    action_not_starts_with: String
    action_not_starts_with_nocase: String
    action_starts_with: String
    action_starts_with_nocase: String
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    farmId: Int
    farmId_gt: Int
    farmId_gte: Int
    farmId_in: [Int!]
    farmId_lt: Int
    farmId_lte: Int
    farmId_not: Int
    farmId_not_in: [Int!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

enum FarmChangeEvent_orderBy {
    action
    block
    farmId
    id
    timestamp
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type PoolChangeEvent implements EntityChangeEvent {
    action: String!
    block: BigInt!
    id: Bytes!
    poolId: Bytes!
    timestamp: BigInt!
}

input PoolChangeEvent_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    action: String
    action_contains: String
    action_contains_nocase: String
    action_ends_with: String
    action_ends_with_nocase: String
    action_gt: String
    action_gte: String
    action_in: [String!]
    action_lt: String
    action_lte: String
    action_not: String
    action_not_contains: String
    action_not_contains_nocase: String
    action_not_ends_with: String
    action_not_ends_with_nocase: String
    action_not_in: [String!]
    action_not_starts_with: String
    action_not_starts_with_nocase: String
    action_starts_with: String
    action_starts_with_nocase: String
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_in: [Bytes!]
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    poolId: Bytes
    poolId_contains: Bytes
    poolId_in: [Bytes!]
    poolId_not: Bytes
    poolId_not_contains: Bytes
    poolId_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

enum PoolChangeEvent_orderBy {
    action
    block
    id
    poolId
    timestamp
}

type Query {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    entityChangeEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EntityChangeEvent
    entityChangeEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: EntityChangeEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: EntityChangeEvent_filter
    ): [EntityChangeEvent!]!
    farmChangeEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FarmChangeEvent
    farmChangeEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: FarmChangeEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: FarmChangeEvent_filter
    ): [FarmChangeEvent!]!
    poolChangeEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolChangeEvent
    poolChangeEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolChangeEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolChangeEvent_filter
    ): [PoolChangeEvent!]!
}

type Subscription {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    entityChangeEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): EntityChangeEvent
    entityChangeEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: EntityChangeEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: EntityChangeEvent_filter
    ): [EntityChangeEvent!]!
    farmChangeEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FarmChangeEvent
    farmChangeEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: FarmChangeEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: FarmChangeEvent_filter
    ): [FarmChangeEvent!]!
    poolChangeEvent(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PoolChangeEvent
    poolChangeEvents(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PoolChangeEvent_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PoolChangeEvent_filter
    ): [PoolChangeEvent!]!
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes

    """
    The block number
    """
    number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    """
    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!

    """
    The deployment ID
    """
    deployment: String!

    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow

    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
